#!/usr/bin/env bash
set -u
set -o pipefail
IFS=$'\n\t'

# -------- config (override via env) --------
OUT_DIR=${OUT_DIR:-results}
LLAMA=${LLAMA:-$HOME/.local/bin/llama-bench} # path to llama-bench binary
THREADS=${THREADS:-4}
PROMPT=${PROMPT:-512}
GEN=${GEN:-128}
REPS=${REPS:-5}
# Optional KV cache quantization (if your build supports it). Leave empty to skip.
CTYPE_K=${CTYPE_K:-} # e.g., q8_0 or q4_0
CTYPE_V=${CTYPE_V:-} # e.g., q8_0 or q4_0

# Limit scope per run
MODELS=${MODELS:-}              # e.g. "tinyllama qwen05b"
QUANTS=${QUANTS:-}              # e.g. "Q4_K_M Q5_K_M"
DELETE_AFTER=${DELETE_AFTER:-0} # 1 = remove just-used hf:// cache file after each run

COOLDOWN_SECS=${COOLDOWN_SECS:-120}

# Model roots (edit paths to match your layout). Values are only "suggested" quants;
# actual quants auto-detect from files unless QUANTS is set.
declare -A MODEL_LIST=(
  ["models/qwen3-06b"]="Q4_K_S Q3_K_M Q5_K_S Q4_K_M Q5_K_M Q3_K_L Q6_K Q8_0"
  ["models/qwen25-05b-instruct"]="Q4_K_S Q3_K_M Q5_K_S Q4_K_M Q5_K_M Q3_K_L Q6_K Q8_0"
  ["models/gemma3-270m-instruct"]="Q4_K_S Q3_K_M Q5_K_S Q4_K_M Q5_K_M Q3_K_L Q6_K Q8_0"
  # ["models/gemma3n-e2b"]="F16"

)

# -------- helpers --------
err() { printf "%s\n" "$*" >&2; }

mkdir -p "$OUT_DIR" || {
  err "Cannot create $OUT_DIR"
  exit 1
}
OUT_CSV="$OUT_DIR/results.csv"
LOG="$OUT_DIR/bench_errors.log"
: >"$LOG" || {
  err "Cannot write $LOG"
  exit 1
}

[[ -x "$LLAMA" ]] || {
  err "ERROR: llama-bench not found at $LLAMA"
  exit 1
}
command -v jq >/dev/null 2>&1 || {
  err "ERROR: 'jq' not found"
  exit 1
}

write_header() {
  if [[ ! -s "$OUT_CSV" ]]; then
    echo "test_time_utc,model,quant,threads,prompt_tps,gen_tps,pg_tps,cpu_info,gpu_info,cuda,vulkan,metal,sycl,gpu_blas,blas,flash_attn,n_gpu_layers,type_k,type_v,bench_opts,source" >"$OUT_CSV"
  fi
}

append_row() { printf "%s\n" "$*" >>"$OUT_CSV"; }
pick_file() {
  local dir="$1" quant="$2"
  # First try a case-insensitive glob (covers Q4_K_M vs q4_k_m)
  local old_flags
  old_flags=$(shopt -p nocaseglob || true)
  shopt -s nocaseglob nullglob
  local matches=("$dir"/*"$quant"*.gguf)
  # Fallback: find (case-insensitive), helpful on odd filesystems/encodings
  if ((${#matches[@]} == 0)); then
    while IFS= read -r -d '' f; do matches+=("$f"); done < <(find "$dir" -maxdepth 1 -type f -iname "*${quant}*.gguf" -print0 2>/dev/null || true)
  fi
  # restore glob behavior
  eval "$old_flags" 2>/dev/null || shopt -u nocaseglob
  shopt -u nullglob

  if ((${#matches[@]} == 0)); then
    # allow direct hf:// via stub
    local hfstub="$dir/$quant.hfpath"
    [[ -f "$hfstub" ]] && {
      cat "$hfstub"
      return 0
    }
    return 1
  fi

  # choose smallest file (often the lower-RAM variant if multiples)
  local best="${matches[0]}" best_size
  best_size=$(stat -c%s "$best" 2>/dev/null || echo 0)
  local f s
  for f in "${matches[@]}"; do
    s=$(stat -c%s "$f" 2>/dev/null || echo 0)
    ((s < best_size)) && {
      best="$f"
      best_size="$s"
    }
  done
  printf "%s\n" "$best"
}

# MODELS is a space-separated filter string; if empty, allow all models.
want_model() {
  local n="$1"
  [[ -z "$MODELS" ]] && return 0
  case " $MODELS " in *" $n "*) return 0 ;; esac
  return 1
}

detect_quants() {
  local dir="$1"
  local -a qs=()
  declare -A seen=()
  shopt -s nullglob
  for f in "$dir"/*.gguf; do
    [[ -e "$f" ]] || continue
    local b q
    b=$(basename "$f")
    q="${b##*-}"
    q="${q%.gguf}"
    [[ -n "$q" && "$q" != "$b" && -z "${seen[$q]:-}" ]] && {
      seen["$q"]=1
      qs+=("$q")
    }
  done
  shopt -u nullglob
  shopt -s nullglob
  for s in "$dir"/*.hfpath; do
    [[ -e "$s" ]] || continue
    local q
    q="$(basename "$s")"
    q="${q%.hfpath}"
    [[ -n "$q" && -z "${seen[$q]:-}" ]] && {
      seen["$q"]=1
      qs+=("$q")
    }
  done
  shopt -u nullglob
  printf "%s\n" "${qs[@]}"
}

delete_hf_cached() {
  local path="$1"
  [[ "$DELETE_AFTER" != "1" || "$path" != hf://* ]] && return 0
  local cache="${XDG_CACHE_HOME:-$HOME/.cache}/llama.cpp"
  local base="${path##*/}"
  find "$cache" -type f -name "$base" -delete 2>/dev/null || true
}

write_header

# -------- run --------
for DIR in "${!MODEL_LIST[@]}"; do
  model="$(basename "$DIR")"
  want_model "$model" || {
    err "skip: $model (filtered)"
    continue
  }
  [[ -d "$DIR" ]] || {
    err "WARN: missing dir '$DIR' â€” skipping $model" | tee -a "$LOG" >/dev/null
    continue
  }

  # build quant list
  declare -a iter_quants=()
  if [[ -n "$QUANTS" ]]; then
    readarray -t iter_quants < <(printf '%s' "$QUANTS" | tr -s '[:space:]' '\n')
  else
    readarray -t iter_quants <<<"$(detect_quants "$DIR")"
    [[ ${#iter_quants[@]} -eq 0 ]] && readarray -t iter_quants <<<"$(printf "%s\n" "${MODEL_LIST[$DIR]}")"
  fi
  ((${#iter_quants[@]} == 0)) && {
    err "WARN: no quants for $model"
    continue
  }

  for Q in "${iter_quants[@]}"; do
    if ! FILE="$(pick_file "$DIR" "$Q")"; then
      err "skip: $model ($Q not found)" | tee -a "$LOG" >/dev/null
      continue
    fi
    SRC="file"
    [[ "$FILE" == hf://* ]] && SRC="hf"
    echo "==> $model / $Q [$SRC]"

    # Build KV flags if provided
    kv_flags=()
    [[ -n "$CTYPE_K" ]] && kv_flags+=("--cache-type-k" "$CTYPE_K")
    [[ -n "$CTYPE_V" ]] && kv_flags+=("--cache-type-v" "$CTYPE_V")

    # Run llama-bench for prompt, gen, and combined (array JSON)
    if ! BENCH_JSON="$(
      timeout 600 "$LLAMA" -m "$FILE" -p "$PROMPT" -n "$GEN" -pg "${PROMPT},${GEN}" \
        -r "$REPS" -o json "${kv_flags[@]}" \
        -t "$THREADS" 2>>"$LOG"
    )"; then
      err "ERROR: bench failed for $model / $Q"
      append_row "NA,$model,$Q,$THREADS,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,bench:p=$PROMPT;n=$GEN;r=$REPS;ctk=${CTYPE_K:-NA};ctv=${CTYPE_V:-NA},$SRC"
      delete_hf_cached "$FILE"
      continue
    fi

    # Validate JSON
    if ! echo "$BENCH_JSON" | jq -e . >/dev/null 2>&1; then
      err "ERROR: invalid JSON for $model / $Q"
      append_row "NA,$model,$Q,$THREADS,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,bench:p=$PROMPT;n=$GEN;r=$REPS;ctk=${CTYPE_K:-NA};ctv=${CTYPE_V:-NA},$SRC"
      delete_hf_cached "$FILE"
      continue
    fi

    # Extract data + produce CSV line
    CSV_LINE="$(echo "$BENCH_JSON" | jq -r \
      --arg m "$model" --arg q "$Q" --arg th "$THREADS" --arg src "$SRC" \
      --arg p "$PROMPT" --arg g "$GEN" --arg r "$REPS" \
      --arg ctk "${CTYPE_K:-NA}" --arg ctv "${CTYPE_V:-NA}" '
      def pick_ts(sel): ( [ .[] | select(sel) | .avg_ts ] | first );
      def pick_time(sel): ( [ .[] | select(sel) | .test_time ] | first );
      def pick_str(field): ( [ .[] | .[field] ] | first );
      . as $arr
      | {
          p_ts:  pick_ts((.n_prompt // 0) > 0 and (.n_gen // 0) == 0),
          g_ts:  pick_ts((.n_gen // 0) > 0 and (.n_prompt // 0) == 0),
          pg_ts: pick_ts((.n_gen // 0) > 0 and (.n_prompt // 0) > 0),
          
          t_pg:  pick_time((.n_gen // 0) > 0 and (.n_prompt // 0) > 0),
          t_any: ([ $arr[] | .test_time ] | first),

          cpu:   pick_str("cpu_info"),
          gpu:   pick_str("gpu_info"),
          cuda:  pick_str("cuda"),
          vulk:  pick_str("vulkan"),
          metal: pick_str("metal"),
          sycl:  pick_str("sycl"),
          gblas: pick_str("gpu_blas"),
          blas:  pick_str("blas"),
          flash: pick_str("flash_attn"),
          ngpu:  pick_str("n_gpu_layers"),
          tk:    pick_str("type_k"),
          tv:    pick_str("type_v"),
          nth:   pick_str("n_threads")
        }
      | [
          # test_time_utc
          (if .t_pg!=null then .t_pg else (if .t_any==null then "NA" else .t_any end) end),
          $m, $q,
          ( ($th // ( .nth|tostring )) ),
          (if .p_ts==null then "NA" else (.p_ts|tostring) end),
          (if .g_ts==null then "NA" else (.g_ts|tostring) end),
          (if .pg_ts==null then "NA" else (.pg_ts|tostring) end),
          (.cpu // "NA"),
          (.gpu // "NA"),
          (.cuda // "NA"),
          (.vulk // "NA"),
          (.metal // "NA"),
          (.sycl // "NA"),
          (.gblas // "NA"),
          (.blas // "NA"),
          (.flash // "NA"),
          (.ngpu // "NA"),
          (.tk // "NA"),
          (.tv // "NA"),
          ("bench:p=" + $p + ";n=" + $g + ";r=" + $r + ";ctk=" + $ctk + ";ctv=" + $ctv),
          $src
        ] | @csv
    ')"
    # Write CSV row
    append_row "$CSV_LINE"

    # Save raw JSON using ONLY JSON time
    JSON_TIME="$(echo "$BENCH_JSON" | jq -r '
      ([ .[] | select((.n_gen // 0) > 0 and (.n_prompt // 0) > 0) | .test_time ] | first)
      // ([ .[] | .test_time ] | first)
      // "unknown"
    ')"
    SAFE_TIME="${JSON_TIME//:/-}" # make filename-safe (replace ":" with "-")
    JSON_PATH="$OUT_DIR/${model}_${Q}_${SAFE_TIME}.json"
    printf "%s\n" "$BENCH_JSON" >"$JSON_PATH"

    delete_hf_cached "$FILE"
  done
  # optional cooldown
  echo "Cooling down CPU for $COOLDOWN_SECS seconds..."
  sleep "$COOLDOWN_SECS"
done

echo "Done. CSV -> $OUT_CSV ; errors -> $LOG ; JSONs -> $OUT_DIR/"
